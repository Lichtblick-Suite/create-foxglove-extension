env:
  node: true

ignorePatterns:
  - dist
  - template

plugins:
  - "@typescript-eslint"
  - jest

extends:
  - eslint:recommended
  - plugin:@typescript-eslint/eslint-recommended
  - plugin:@typescript-eslint/recommended
  - plugin:@typescript-eslint/recommended-requiring-type-checking
  - plugin:import/errors
  - plugin:import/warnings
  - plugin:import/typescript
  - plugin:prettier/recommended

parser: "@typescript-eslint/parser"
parserOptions:
  ecmaVersion: 2019
  sourceType: module
  project: ./tsconfig.json

rules:
  id-denylist:
    - error
  "@typescript-eslint/ban-ts-comment": error
  # It's sometimes useful to explicitly name to guard against future changes
  "@typescript-eslint/no-inferrable-types": off
  "@typescript-eslint/no-empty-function": off
  "@typescript-eslint/no-implied-eval": off

  # These could theoretically be turned on (or merit investigation) but are currently noisy
  "@typescript-eslint/no-misused-promises": off
  "@typescript-eslint/no-floating-promises": off
  "@typescript-eslint/restrict-template-expressions": off
  "@typescript-eslint/no-unsafe-member-access": off
  "@typescript-eslint/no-unsafe-return": off
  "@typescript-eslint/no-unsafe-assignment": off
  "@typescript-eslint/no-unsafe-call": off
  "@typescript-eslint/require-await": off
  "@typescript-eslint/prefer-regexp-exec": off
  "@typescript-eslint/no-unnecessary-condition": off # similar to strict-boolean-expressions, but catches more (noisy) cases?

  "@typescript-eslint/consistent-type-assertions":
    - error
    - { assertionStyle: as }
  "@typescript-eslint/no-explicit-any": error
  "@typescript-eslint/prefer-nullish-coalescing": error
  "@typescript-eslint/no-non-null-assertion": error
  "@typescript-eslint/no-confusing-non-null-assertion": error
  "@typescript-eslint/no-unnecessary-boolean-literal-compare": error
  "@typescript-eslint/prefer-includes": error
  "@typescript-eslint/prefer-optional-chain": error
  "@typescript-eslint/restrict-plus-operands": [error, { checkCompoundAssignments: true }]
  "@typescript-eslint/switch-exhaustiveness-check": error
  "@typescript-eslint/unbound-method": [error, { ignoreStatic: true }]
  "@typescript-eslint/explicit-module-boundary-types": error

  no-console: error
  no-new-func: error

  curly: error
  # This rule is similar to TS's noUnusedLocals/noUnusedParameters, but we still want to enable the
  # check for any .js files
  "@typescript-eslint/no-unused-vars":
    - error
    - { vars: all, args: after-used, varsIgnorePattern: "^_", argsIgnorePattern: "^_" }
  no-underscore-dangle:
    - error
    - allowAfterThis: true
  no-warning-comments:
    - error
    - terms: ["fixme", "xxx"]
      location: anywhere
  # Some good ones that people really should be adding to import/recommended:
  import/first: error
  import/newline-after-import: error
  import/no-duplicates: error
  import/no-mutable-exports: error
  import/no-self-import: error
  import/no-useless-path-segments: error
  # Group imports into three groups [external, internal, relative] and sort alphabetically within each group
  import/order:
    - error
    - alphabetize: { order: asc }
      newlines-between: always
      groups: [[builtin, external], [internal], [parent, sibling, index]]

  # we let typescript handle whether imports exist or not
  import/namespace: off
  import/default: off
  import/no-named-as-default: off
  import/no-named-as-default-member: off
  import/no-unresolved: off

  prefer-arrow-callback:
    - error
    - allowNamedFunctions: true
  "@typescript-eslint/no-shadow": error
  no-restricted-imports: error
  no-restricted-syntax:
    - error
    - selector: "MethodDefinition[kind='get'], Property[kind='get']"
      message: "Property getters are not allowed; prefer function syntax instead."
    - selector: "MethodDefinition[kind='set'], Property[kind='set']"
      message: "Property setters are not allowed; prefer function syntax instead."
    # Ban `null [!=]= x` and `x [!=]= null`
    - selector: "BinaryExpression:matches([operator='=='], [operator='!=']):matches([left.type=Literal][left.raw=null], [right.type=Literal][right.raw=null])"
      message: 'Prefer "x == undefined" or "x != undefined" to check for both null and undefined.'
    # Ban `undefined [!=]= x`
    - selector: "BinaryExpression:matches([operator='=='], [operator='!='])[left.type=Identifier][left.name=undefined]"
      message: 'Prefer "x == undefined" or "x != undefined" to check for both null and undefined.'
    # Ban `==` and `!=` unless RHS is undefined
    - selector: "BinaryExpression:matches([operator='=='], [operator='!=']):not([right.type=Identifier][right.name=undefined]):not([right.type=Literal][right.raw=null])"
      message: 'Use strict equality operators "===" and "!==", except when checking for null or undefined.'

    - selector: "TSNullKeyword, Literal[raw=null]"
      message: >
        Prefer undefined instead of null. When required for React refs/components, use
        the `ReactNull` alias. Otherwise, if strictly necessary, disable this error with
        `// eslint-disable-next-line no-restricted-syntax`. For rationale, see:
        https://github.com/sindresorhus/meta/discussions/7"

    - selector: "TSPrivateIdentifier"
      message: "Use private instead of #"

  "@typescript-eslint/strict-boolean-expressions":
    - error
      # Force explicit checks that strings are empty
    - allowString: false
      # Force explicit checks that numbers are != 0 or NaN
      allowNumber: false

  jest/no-disabled-tests: error
